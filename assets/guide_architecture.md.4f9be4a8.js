import{_ as a,c as e,o as r,O as t}from"./chunks/framework.3ec6c483.js";const b=JSON.parse('{"title":"Архітектурні рішення","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture.md"}'),o={name:"guide/architecture.md"},i=t('<h1 id="архітектурні-рішення" tabindex="-1">Архітектурні рішення <a class="header-anchor" href="#архітектурні-рішення" aria-label="Permalink to &quot;Архітектурні рішення&quot;">​</a></h1><h2 id="ядро-програми" tabindex="-1">Ядро програми <a class="header-anchor" href="#ядро-програми" aria-label="Permalink to &quot;Ядро програми&quot;">​</a></h2><p>Весь ключовий код програми міститься в KCTT.cpp. Це старт програми, мета якого налаштувати поточне середовище програми, її візуальний вигляд, а також запуск стартового меню з можливістю авторизації та виведенням причетних розробників.</p><h2 id="зберігання-даних-програми" tabindex="-1">Зберігання даних програми <a class="header-anchor" href="#зберігання-даних-програми" aria-label="Permalink to &quot;Зберігання даних програми&quot;">​</a></h2><p>Для того, щоб у процесі роботи над функціональністю системи не виникало великих проблем із маніпуляціями даними, було реалізовано такі технічні рішення:</p><h3 id="глобальнии-стор" tabindex="-1">Глобальний стор <a class="header-anchor" href="#глобальнии-стор" aria-label="Permalink to &quot;Глобальний стор&quot;">​</a></h3><p>Глобальний статичний клас GlobalStore, де зберігаються дані авторизованого користувача, локальні сховища подій, квитків, користувачів, а також початкова ініціалізація даних.</p><h3 id="локальні-стори" tabindex="-1">Локальні стори <a class="header-anchor" href="#локальні-стори" aria-label="Permalink to &quot;Локальні стори&quot;">​</a></h3><p>Це спеціалізовані класи, які займаються сховищем певного типу даних і надають методи для додавання, видалення, отримання даних з використанням різних способів, передбачених класом.</p><p>У проєкті вони використовуються в глобальному сторі, але так само мають можливість створення локальних сховищ.</p><h2 id="авторизація" tabindex="-1">Авторизація <a class="header-anchor" href="#авторизація" aria-label="Permalink to &quot;Авторизація&quot;">​</a></h2><p>Для розподілу ролей було ухвалено рішення створити абстрактний клас User, мета якого - визначити поля, які мають бути як для Адміністратора, так і для Покупця.</p><p>Це ім&#39;я, логін, пароль, роль і ще деякі методи (про них далі). Коли на початковому екрані користувач вводить логін і пароль, ядро системи робить пошук за логіном, а також звіряє паролі через внутрішню функцію User класу.</p><h2 id="розподіл-ролеи" tabindex="-1">Розподіл ролей <a class="header-anchor" href="#розподіл-ролеи" aria-label="Permalink to &quot;Розподіл ролей&quot;">​</a></h2><p>Ми створюємо дочірні класи Admin і Customer, які успадковуються від User. Оскільки сховище користувачів використовує батьківський клас User, для визначення ролі в дочірніх класах у конструкторі ми перевизначаємо роль цього користувача.</p><h2 id="вибір-діи" tabindex="-1">Вибір дій <a class="header-anchor" href="#вибір-діи" aria-label="Permalink to &quot;Вибір дій&quot;">​</a></h2><p>Після того, як користувач авторизувався, ядро системи викликає функції User, які виводять меню й активують його, просячи користувача ввести потрібний символ. Щоб меню дій були різні для Адміністратора і Покупця, у дочірніх класах User йде перевизначення цих методів, щоб покрити всю необхідну функціональність системи.</p><h2 id="функціональність" tabindex="-1">Функціональність <a class="header-anchor" href="#функціональність" aria-label="Permalink to &quot;Функціональність&quot;">​</a></h2><p>Усі можливі дії Адміністратора і Користувача розбиті на функції і займаються маніпулюванням даних у сховищах. Там так само реалізовано перевірки на існування і коректність, які не дають зламати систему.</p>',19),h=[i];function l(n,s,c,d,p,u){return r(),e("div",null,h)}const m=a(o,[["render",l]]);export{b as __pageData,m as default};
